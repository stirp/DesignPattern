Java设计模式
==========

6. factory

> 实用度：5<br />
> 常见度：5

工厂模式主要用来来隐藏创建对象时的复杂度。
它分以下三种：

  1).简单工厂

目的：简单工厂就是为了隐藏创建对象的复杂度，
将其封装到一个方法内，可以创建出实现同一个
接口的不同的对象，来满足不同的需求。
使用条件类似于一家咖啡店，甲要了卡布奇诺，
乙要了速溶咖啡。

  2).抽象工厂

目的：抽象工厂不是简单工厂的升级版，而是与简单
工厂抽象的维度不同。对于抽象工厂来说，
不同的工厂都能创建一套产品，但是产品的不同
是依赖工厂的不同。这就像是两家咖啡店，在甲店
要的咖啡量多，饼干偏咸，乙店咖啡量少，饼干偏甜。

  3).工厂方法

目的：工厂方法是简单工厂和抽象工厂的结合，
工厂本身是抽象的，可以有多个工厂实例；
对象是靠不同函数而是以不同参数来隔离，
这与简单工厂一样。
13. templateMethod

> 实用度：3<br />
> 常见度：3

目的: 模板方法的目的是对外部彻底隐藏不同实现
的使用方式。比如，不管是盖两层楼还是盖三层楼，
都需要先打地基，再搭框架，再搭外墙。它本身不
决定选择哪个实现。通常会有一个抽象基类来完成
不同实现都需要的逻辑，在Java10以后接口本身
基本就可以实现基类的能力了（在接口中实现
非公有函数）。

缺点：如果需求会产生不同实现顺序上不一致的情况，
那就会导致这个系统被破坏，无法使用。

9. proxy

> 实用度：5<br />
> 常见度：5

目的: 代理通常是用来对一组目标做统一的逻辑，
而无需更改每个对象。

分类: 
远程代理：将远程访问逻辑放到代理内，由代理
维护远程访问的过程。比如各种rpc
虚拟代理：如果资源状态复杂，在达到某种条件
之前无法使用，那么非常合适使用虚拟代理，
由虚拟代理维护状态，并在准备好之后再提供
访问能力
保护代理：用于保护目标不被非法访问
智能引用代理：存有目标的引用信息，
如耗时、次数等
缓存代理：获取到目标后持有目标信息，
以便后续访问
11. state machine
12. strategy
1. adapter
2. command
4. decorator
3. composite
10. singleton
7. iterator
5. facade

> 实用度：3<br />
> 常见度：5

外观模式是把子系统的灵活和复杂用一种外观固定下来，一般来说可以看做是一种有损的封装，损失的是外部系统不需要的灵活度。

目的：隐藏复杂度，保持对外部系统的简洁，方便他人使用

已有的实现：由于子系统都是由自己开发，因此没有通用的外观模式。

缺点：隐藏了灵活性，如果外部系统需要更多的功能，需要修改facade。

8. 观察者模式
> 实用度：1<br />
> 常见度：1

观察者模式用于隐藏变化通知相关方有关注的信息变更，使得变更和通知在代码中隐藏。分为推送式的观察者和拉取式的观察者。

目的：变更发生和引发的改变变更方不关心，或者代码中有两个对象相关有关联，但是需要单独复用，那么观察者模式就是合适的。

已有的实现：
* [java.util.Observer]()（自Java1.9废弃）

缺点:
默认的实现是同步调用，如果观察者过多，或者观察者更新耗时过长，则影响性能；如果异步通知，则存在变化频繁，一次拉取中收到多次通知，导致重复拉取的情况。在分布式和多线程环境中使用较为不方便。

替代方案：
* 考虑使用事件机制 [java.util.EventListener]() 而不是观察者模式
* 考虑使用并发的数据结构在线程间传递信息
* 考虑使用反应式流来替换观察者模式